# 상속 

## 기초  클래스

오리지널 클래스를 기초클래스,

상속받는 클래스를 파생 클래스



### 클래스 파생

class N{

int n1;

int n2;

public:

N(int num1, int num2): n1(num1), n2(num2);

}


class d_N :public N{

...

}

:은 N클래스에 기초하고 있다는 것 나타냄

N이 public 기초 클래스 나타냄

public파생이라고 함

기초클래스의 public 멤버들이 파생클래스 public멤버 됨.

private부분도 파생클래스 일부 됨

그러나 기초 클래스의 protected, public으로만 접근 가능



### 생성자 접근

파생클래스는 기초 클래스 private에 직접 접근 불가

파생클래스의 생성자는 기초 클래스의 생성자 사용



프로그램이 파생 클래스의 객체 생성할 때, 먼저 기초클래스의 객체를 생성. 기초 클래스가 먼저 새성 되어야 한다는 것 의미

d_N(...) :N(num1, num2){...}

생략시 디폴트 생성자 사용



파생 클래스 파괴자의 몸체가 먼저 실행됨

그리고 기초 클래스 파괴자 자동 호출

기초 클래스 포인터는 명시적 변환 없이도 파생클래스 객체 지시 가능, 참조도 가능



그러나 기초 클래스 메서드만 호출 가능



## 상속 is a 관계

public상속이 가장 일반적인 형식

is a 관계 나타냄 -> 파생클래스가 기초 클래스이기도 한다는 것 의미



기초 클래스 객체를 대상으로 수행 가능한 모든 작업을 파생 객체 클래스에 대해서는 수행 가능.

## public 다형 상속

구현 법

- 기초 클래스 메서드를 파생클래스에서 다시 정의

- 가상 메서드 사용

class N{

private:

int n1;

int n2;

public:

...

virtual void show();//가상

}

class d_N : public N{

private:

int n3;

public:

..

virtual void show();

...

}

만약 show()가 가상 아니면

N n(1,2);

d_N d_n(3);

N &nref1 = n;

N &nref2 = d_n;

nref1.show(); //N::show()

nref2.show(); //N::show(), 만약 가상이면 d_N::show()



virtual은 참조나 포인터에 의해 지시되는 객체에 기초하여 메서드 선택



### 포인터, 참조형의 호환

동적 결합은 포인터와 참조에 의해 호출되는 메서드와 연관.

부분적으로 상속과정에 의해 지배 받음.



일반적으로, 다른 데이터 형을 참조나 지시 불가

그러나 기초클래스는 파생클래스 참조 지시 가능



파생 클래스 참조나 포인터를 기초 클래스 참조나 포인터로 변환하는 것을 업캐스팅이라고 함

public상속에서는 명시적 변환없이 업스캐팅 언제는지 허용됨

is a관계



반대 과정을 다운 캐스팅이라고 함. 명시적은 데이터형 변환 없이는 허용 x



### 가상 메서드에 대해 알아야 할 것

- 상속을 위해 기초클래스로 사용할 클래스 저으이 할때, 파생클래스에서 다시 정의해야 하는 클래스 메서드들은 가상함수로 선언



생성자

가상으로 선언 불가. 파생클래스 객체 생성은 파생클래스 생성자가 호출됨. 이 생성자가 기초 클래스 생성자 사용



파괴자

클래스가 기초 클래스로 사용되면, 파괴자는 가상으로 선언

만약 파생클래스에서 new 멤버 있을 시 문제

기초 *p = new파생클래스;

delete p; //~기초? ~파생?

기초 파괴자 호출. 파생클래스 new멤버 남아있음



프렌드

가상 함수 불가



가상 함수 다시 정의 하지 않으면

파생 클래스가 함수 다시 정의하지 않으면, 그 함수의 기초 클래스 버전 사용. 이 버전이 은닉인 경우는 예외



가상 함수 다시 정의하면 은닉이 됨.



## 접근 제어 protected


밖에서는 접근 못함.(private)

그러나 파생 클래스는 기초 클래스 protected 멤버에 직접 접근 가능



private를 사용하는 것이 더 좋음. 파생 클래스가 기초 클래스 데이터에 접근하기 위해 기초 클래스 메서드 이용



## 추상화 기초 클래스(ABC)

원을 타원클래스에 파생되는 것은 비효율적

그래서 원 타원으로부터 공톡적인 거 추출, ABC에 넣을 수 있음.



두 클래스에 서로 다르게 작용하는 메서드는 ABC에 구현 불가(필요한 멤버 없음)

이러한 함수 위해 순수 가상함수 제공

함수 선원 뒤에 =0있음

virtual int sum() const = 0;



클래스 선언에 순수 가상함수 있으면 ,그 클래스의 객체 생성불가

그 클래스가 반드시 정의할 필요 없음.



## 상속, 동적 메모리 대입

기초 클래스는 new사용

1. 파생 nex x

파생 클래스를 위해, 파괴자, 복사 생성자, 대입 연산자 정의 안 해도 됨.



기초 클래스 파괴자 항상 호출함



디폴트 복사 생성자는 멤버별 복사함. 동적 메모리에 사용 불가, 기초 클래스 객체 묹 ㅔ있음.

멤버별 복사는 데이터형에 맞게 정의된 복사 형식 사용,

클래스 멤버, 상속받은 클래스 성분 복사하는 것은 그 클래스의 복사 생성자 통하여 이루어짐.



파생 클래스의 디폴트 복사 생성자는, 파생클래스의 기초 클래스 복사 생성자 사용

=> 파생 클래스의 디폴트 복사 생성자는 둘 다 사용 가능. 대입도 이와 같음.



2. 파생 클래스 new 사용

파생 클래스 위한 파괴자, 복사 생성자, 대입연산자 정의 필요



파생 클래스 복사 생성자는 기초 클래스 성분 다루기 위해 기초 클래스 복사 생성사 호출 해야됨.



파생 :: 파생(const 파생 &hs) : 기초 클래스 복사 생성자(hs){~~}

기초 클래스 참조가 파생형도 이용 가능



파생 클래스의 명시적 대입 연산자는 기초 클래스 객체 위한 대입 처리 가능 해야 됨. 기초 클래스는 대입 연산자 명시적으로 호출함으로써 처리가능



파생 &파생 ::operator=(const 파생 &hs){

...

기초 :: operator=(hs); //기초 클래스 복사

delete 기초 new; //새로운거 준비

...

}
