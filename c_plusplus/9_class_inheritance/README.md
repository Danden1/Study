# 상속 

## 기초  클래스

오리지널 클래스를 기초클래스,

상속받는 클래스를 파생 클래스



### 클래스 파생

class N{

int n1;

int n2;

public:

N(int num1, int num2): n1(num1), n2(num2);

}


class d_N :public N{

...

}

:은 N클래스에 기초하고 있다는 것 나타냄

N이 public 기초 클래스 나타냄

public파생이라고 함

기초클래스의 public 멤버들이 파생클래스 public멤버 됨.

private부분도 파생클래스 일부 됨

그러나 기초 클래스의 protected, public으로만 접근 가능



### 생성자 접근

파생클래스는 기초 클래스 private에 직접 접근 불가

파생클래스의 생성자는 기초 클래스의 생성자 사용



프로그램이 파생 클래스의 객체 생성할 때, 먼저 기초클래스의 객체를 생성. 기초 클래스가 먼저 새성 되어야 한다는 것 의미

d_N(...) :N(num1, num2){...}

생략시 디폴트 생성자 사용



파생 클래스 파괴자의 몸체가 먼저 실행됨

그리고 기초 클래스 파괴자 자동 호출

기초 클래스 포인터는 명시적 변환 없이도 파생클래스 객체 지시 가능, 참조도 가능



그러나 기초 클래스 메서드만 호출 가능



## 상속 is a 관계

public상속이 가장 일반적인 형식

is a 관계 나타냄 -> 파생클래스가 기초 클래스이기도 한다는 것 의미



기초 클래스 객체를 대상으로 수행 가능한 모든 작업을 파생 객체 클래스에 대해서는 수행 가능.

## public 다형 상속

구현 법

- 기초 클래스 메서드를 파생클래스에서 다시 정의

- 가상 메서드 사용

class N{

private:

int n1;

int n2;

public:

...

virtual void show();//가상

}

class d_N : public N{

private:

int n3;

public:

..

virtual void show();

...

}

만약 show()가 가상 아니면

N n(1,2);

d_N d_n(3);

N &nref1 = n;

N &nref2 = d_n;

nref1.show(); //N::show()

nref2.show(); //N::show(), 만약 가상이면 d_N::show()



virtual은 참조나 포인터에 의해 지시되는 객체에 기초하여 메서드 선택



### 포인터, 참조형의 호환

동적 결합은 포인터와 참조에 의해 호출되는 메서드와 연관.

부분적으로 상속과정에 의해 지배 받음.



일반적으로, 다른 데이터 형을 참조나 지시 불가

그러나 기초클래스는 파생클래스 참조 지시 가능



파생 클래스 참조나 포인터를 기초 클래스 참조나 포인터로 변환하는 것을 업캐스팅이라고 함

public상속에서는 명시적 변환없이 업스캐팅 언제는지 허용됨

is a관계



반대 과정을 다운 캐스팅이라고 함. 명시적은 데이터형 변환 없이는 허용 x



### 가상 메서드에 대해 알아야 할 것

- 상속을 위해 기초클래스로 사용할 클래스 저으이 할때, 파생클래스에서 다시 정의해야 하는 클래스 메서드들은 가상함수로 선언



생성자

가상으로 선언 불가. 파생클래스 객체 생성은 파생클래스 생성자가 호출됨. 이 생성자가 기초 클래스 생성자 사용



파괴자

클래스가 기초 클래스로 사용되면, 파괴자는 가상으로 선언

만약 파생클래스에서 new 멤버 있을 시 문제

기초 *p = new파생클래스;

delete p; //~기초? ~파생?

기초 파괴자 호출. 파생클래스 new멤버 남아있음



프렌드

가상 함수 불가



