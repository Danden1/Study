# 클래스, 동적 메모리

## 동적 메모리, 클래스

프로그램에서 하나의 객체 다른 객체로 초기화시, 컴파일러는 복사 생성자 발생, 객체의 사본 만듬



복사 생성자

새로 생성되는 객체에 어떤 객체를 복사하는데 사용

class_name (const class_name &);



const참조 매개변수로 활용



새로운 객체가 생성되어 기본의 객체로 초기화 할때 마다 호출



디폴트 복사 생성자는 static 멤버 제외하고 멤버 별로 복사(얕은 복사) 값으로 복사함

ex)

class name{ 

private:

char *str;

...

}

n1.str= n2.str;

문자열을 지시하는 포인터 복사. 두 포인터는 동일한 문자열 지시

파괴자로 delete [] n1.str 하면 n2.str???

명시적 복사 생성자로 해결 가능 (깊은 복사)



ex)

name::name(const name &n){

...

str::strcpy(str, n.str); //해결

...

}



오버로딩 대입 연산자는 하나의 객체 기존의 다른 객체에 대입할 때 사용



name n1("N");

name n2;

n2 = n1; //오버로딩 대입 연산자 호출

name n3 = n1; //복사 생성자 사용, 대입도 가능

대입 연산자의 암시적 구현은 얕은 복사 수행



name & name :: operator=(const name &n){

...

str::strcpy(str, n.str);

...

return *this;

}



## 생성자에 new사용 주의

- 생성자에서 new사용하여 멤버 초기화 시, 파괴자에 delete사용

- 생성자 여러개 일경우, 모든 생성자가 같은방법으로 new사용

- 깊은 복사 통해 하나의 객체를 다른 객체로 초기화 시키는 복사 생성자 정의

- 깊은 복사 통해 하나의 객체를 다른 객체에 대입하는 대입 연산자 정의



## 객체 리턴

### const객체에 대한 참조 리턴

어떤 함수가 자신에게 전달된 객체 리턴 한다면, 참조 전달로 효율성 높일 수 있음.

ex) 대소 비교



### 객체 리턴

리턴되는 객체가 함수에서 지역적인, 함수 종료시 파괴자 호출 - > 참조로 리턴 x



class N{

private:

constint n3;

...

}

N:N(int tmp){

...

n3 = tmp; //안됨

...

}

const는 값 대입 불가

객체가 생성될 때 초기화해야됨.

c++ 멤버 초기화 리스트 제공

N::N(int tmp) : n3(tmp) //n3을 tmp로 초기화



생성자만 사용 가능

참조로 선언된 멤버들로 사용해야 됨.

참조로 생성 될 대 초기화 해야되기 때문






