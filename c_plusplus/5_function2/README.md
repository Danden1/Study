# 함수의 활용

## c++ 인라인 함수

프로그램의 실행속도를 높이기 위해 c++에서 보강된 것.

일반함수와 인라인 함수의 큰 차이는 컴파일러가 코드를 프로그램이 어떻게 결합하느냐에 있음

이해하려면 내부구조 알아야됨.



컴파일 작업의 최종 산출물은 기계어 명령으로 이루어진 실행 프로그램.

프로그램 실행 -> 운영체제는 명령들을 컴퓨터의 메모리에 로드-> 로드된 명령은 특정 메모리 주소를 가짐.

컴푸터는 명령들을 순차적으로 실행



루프나 분기문 만나면, 프로그램은 앞이나 뒤의 특정 주소로 점프하여 명령들을 건너뜀.

일반적인 함수의 호출은 프로그램을 그 함수의 주소로 점프 시켰다가, 함수의 처리가 종결되면 다시 원래자리로 돌아옴.

함수 호출 명령에 도달했을 때, 그 함수 명령 다음에 있는 명령의 주소를 메모리에 저장 -> 스택에 매개변수 복사-> 그 함수가 시작되는 메모리 위치로 점프

> 그 함수 실행 -> 리턴 값 레지스터에 복사 -> 저장해둔 주소의 명령으로 돌아옴.

앞뒤로 점프 수행. 점프 위치 기억하려면 함수를 사용하는 데 시간이 많이 걸림.

c++인라인 함수가 이 문제 해결

컴파일러가 함수 호출을 함수코드로 대체

점프 필요 x 

메모리 측면에서는 불리

함수 코드를 수행하는 데 걸리는 시간이 매우 짧은 경우에만 인라인 함수가 시간 더 절약

사용은 함수 선언 앞에 inline 

함수 정의 앞에 inline

인라인 함수는 재귀 x



## 참조 변수

참조는 미리 정의된 어떤 변수의 실제이름 대신 쓸 수 있는 대용 이름

참조를 매개변수로 사용 시 원본 데이터로 작업가능

클래스 설계할 때 이용됨.

### 생성

int rats;

int &roodents = rats //rats의 대용 이름

이 둘은 모두 같은 값과 같은 메모리 위치 참조

&rats == &roodents

포인터랑 다른 점은 참조 변수는 선언하는 동시에 초기화 해야함.

int bunnies = 50;

roodents = bunnies;

roodents, rats의 값은 50이 되고, roodents는 여전히rats



int rats = 101;

int *pt = &rats;

int &roodebnts = *pt;

int buunies = 50;

roodents는 여전히 rats 참조

### 함수 매개변수 로서의 참조

주로 함수의 매개변수로 사용 됨.

- 참조를 전달하는 함수, 포인터 함수 비교

void swapr(int &a, int &b);

void swapp(int *a, int *b);

1. 매개변수가 선언되는 방식

2. 포인터를 이용하는 경우, *사용하여 원본에 접근



### 특성

double cube(double a){

a *=a;

return a;

}

double refcube(double &a){

ra *= ra;

return ra;

}

cube()는a를 변경해도 main()에 있는 변수에 영향 x

refcube()는 영향을 줌

cube(x+3.0); // 가능

refcube(x+3.0); //불가능

최신 c++에서는 에러

가끔 아닌 경우도 있음

이런 경우 에는,

이름 없는 임시변수를 만들어, x+3.0 의 값으로 초기화 함.

ra는 그 임시변수에 대한 참조가 됨.

최근 c++는 매개변수가 const참조 일 경우 에만 이것을 허용

참조매개변수가 const일 경우, 다음 상황에서 임시 변수 생성

-실제 매개변수가 올바른 형태, lvalue가 아닐때.

(lvalue 매개변수는 참조가 가능한 데이터 객체. 일반 상수, 여러 개의 항으로 이루어진 표현식은 lvalue가 아님)

- 실제 매개변수가 잘못된 데이터 형이지만, 올바른 데이터 형으로 변환 가능 할때



swap을 목적으로 하는 함수에서 임시변수 사용하면 서로 값이 변경아 안됨.

임시 변수들의 값을 서료 교환하기 때문



가능하면 const사용이 좋음.

1. 실수로 데이터 변경을 일으키는 에러 막을 수 있음.

2. 원형에 const사용 시 const와 const가 아닌 실제 매개변수 처리 가능. 생략시 const가 아닌 데이터만 처리 가능.

3. const참조 시 함수가 자신의 필요에 따라 임시 변수 생성하여 사용가능.

### 구조체에 대한

참조는 구조체나 클래스 다루는 데 유용

-전통적인 리턴, 참조 리턴 차이

전통적인 리턴은 함수가 종료되면 리턴에 의해 그 값은 다시 호출한 함수로 전달됨.

이 값은 임시장소에 복사되고 호출 프로그램은 이 값 사용

참조 리턴시 주의점

함수가 종료할 대 수명이 함께 끝나는 메모리 위치에 대한 참조를 리턴하지 않도록



이 문제 피하는 간단한 방법 : 매개변수로 전달된 참조 리턴

### 참조 매개변수는 언제 사용 하는지

1. 호출 함수에 있는 데이터 객체의 변경을 허용

2. 프로그램 속도 향상 위해



함수가 데이터를 사용만 하는 경우

1. 기본 데이터형, 작은 구조체는 값으로 전달

2. 데이터 객체가 배열이면 포이터가 유일한 선택.

const를 지시하는 포인터

3. 큰 구조체 라면 const포인터, const참조 사용. 시간과 공간 절약

4. 클래스 객체이면 const 참조 사용



함수가 데이터 변경하는 경우

1. 기본 데이터형이면 포인터 사용

2. 배열이면 포인터 사용

3. 구조체는 참조나 포인터

4. 클래스는 참조 사용


## 디폴트 매개변수

함수호출에서 매개변술르 생략했을 경우에 매개변수 대신 사용 된는 것.


함수 원형으로 디폴트 값 설정 가능

int sum(int n1, int n2, int n3 = 1);

n3을 1로 초기화함.

n3을 그대로 두면 1이 되지만, 매개벼수를 전달 시, 새로운 값이 1을 대체


디폴트 매개변수를 오른쪽에서 왼쪽의 순서로 첨가해야 됨.

int sum(int n1, int n2=2, int n3);//불가

int sum(int n1=1, int n2=2, int n3=3); //가능


s = sum(2); //2,2,3

s = sum(4,3); //4,3,3

s = sum(4,3,2); //4,3,2


매개변수를 건너 뛸수 없음.


## 함수 오버로딩

서로 다른 여러 개의 함수가 하나의 이름을 공유


void print(double d); //1

void print(int n); //2

print(199.0); //1

print(3); //2


동일한 시그내쳐를 가지고 있는 함수 원형 찾아줌.


double cube(double x);

double cube(double &x);

오버로딩 불가능


const, const가 아닌 변수는 구별됨.

const가 아닌 변수에는 const가 아닌 변수만 전달 가능하기 때문에.


## 함수 템플릿

구체적인 데이터형을 포괄할 수 있는 일반형으로 함수를 정의


어떤 데이터 형을 템플릿에 매개변수로 전달, 컴파일러가 그 데이터 형에 맞는 함수 생성.


ex)

template <class Any> //typename도 가능

void swap(Any &a, Any &b){

	Any tmp;

	tmp = a;

	a = b;

	b= tmp;

}


다양한 데이터 형에 대해 동일한 알고리즘을 적용해야 하는 함수는 템플릿이 유용



위쪽에 템플릿 함수 원형 쓰고, 뒤에 정의 쓰는 경우가 대부분



### 템플릿 제한


template <class T>

void f(T a, T b){...}

T형이 built-in 배열형이면 해당 구문은 참이 아님

a=b;

if(a>b) //T가 일반 구조체이면 참이 아님



### 명시적 특수화


struct job{

	char name[10];

	double salary;

	int floor;

};


두 구조체의 내용 교환 시도

tmp = a;

a = b;

b= tmp;

Any 형이 job구조체인 경우에도 잘 작동

but, name 멤번느 그대로 두고 싶으면, 코드 수정 해야됨


명시적 특수화라는 특수화된 함수 정의를, 필요한 코드와 함께 제공 가능


컴파일러가 함수 호출에 대응하는 정의 발견시, 그 정의를 사용




c++표준이 요구하는 현재 방식

3세대 특수화(ISO, ANSI C++표준)

1. 함수 이름이 하나 주어지면, 템플릿이 아닌 함수, 템플릿 함수, 특수화 템플릿 함수 가질 수 있음. 오버로딩 버전도 가능

2. 원형과 정의 앞에 template<> 오고, 그 특수형의 이름 서술해야 됨.

3. 특수화는 템플릿 무시, 템플릿이 아니 함수는 둘다 무시



template<class T>

void swap(T &a, T &b); // 템플릿

//job에 대한 특수화

template <> void swap<job>(job &, job &);

int main(){

	double u,v;...

	swap(u,v); //템플릿
	
	job a,b; ...

	swap(a,b) //특수화

}

<job>은 생략 가능


### 구체화와 특수화

소스코드에 함수 템플릿을 넣는다고 해서 함수 정의가 저절로 생성되지 않음.

함수 정의를 생성할 계획을 세우는 것.

컴파일러가 특정 데이터 형에 맞는 함수정의를 생성하기 위해 템플릿 사용시, '템플릿의 구체화' 라고 함.	


template void swap<int>(int &, int &); //구체화


swap() 템플릿을 사용하여 int형에 맞는 함수 정의를 생성


template <> swap(int &, int&); // 특수화

swap()템플릿 사용하지 말고, int형에 맞게 명시적으로 정의된 함수를 사용



명시적 구체화는 프로그램에서 함수 사용하여 생성 가능


ex>

template <class T>

T add( T a, T b){return a+b;}

int m = 6;

double x = 10.2;

cout << add<double>(x,m) //명시적 구체화

템플릿은 add(x,m) 와 매치되지 않음. 데이터 형이 다르기 때문.

add<double>은 double 구체화 강요. (double, double) 이 됨.

swap <double> (m,x)는 작동하지 않음.

매개변수가 double &형이라서 int형 변수는 m을 참조 불가.



### 컴파일러는 어느 함수 선택?

1. 후보 함수들의 목록을 만듬. 호출된 함수와 이름 동일 or 함수 템플릿

2. 계속 존속할 수 있는 함수 목록을 만듬. (매개변수의 개수가 일치하는 함수)

이름에 대해 암시적 변환 절차 이루어짐. 실제 매개변수의 각 데이터 형이 대응하는 형식 매개 변수의 데이터 형과 일치하는 경우도 포함.

3. 가장 적절한 함수가 있는지 판단.


### 사용자 선택

ex)

template <class T>

T plus(T a, T b){return a+b;}//1

int plus(int a, int b){ return a+b;}//2

plus(3,4); //2

plus(3.0, 4.0); //1

plus<> (3,4); // 1

plus<int> (3,4); //1

### decltype(c++11)

int x;

decltype(x) y; // x와 동일한 타입의 y 생성

decltype(x+y) s = x+y; //x+y와 동일한 타입



decltype(expression) var;

1. expression 이 괄호가 없는 식별자 인 경우, var는 식별자와 동일한 타입, const를 포함하게 됨

2. 함수 호출일 경우, var는 함수 리턴형

3. lvalue 일 경우, var는 expression 타입참조. 괄호를 추가 해줘야됨.

ex)

int x = 3;

decltype ((x)) r = x; //r은 int& 형

4. 어떠한 특별한 경우로 적용된 적이 없을 시, expression 과 동일한 타입

int j =3;

int &n = j;

int &k = j;

decltype(n+k) i // int 타입



typedef decltype (x) xtype;

xtype y;

xtype ui[10];

이렇게도 사용 가능



### trailng return type(c++11)

template <class T1, class T2>

?? gt(T1 x, T2 y){...return x+y;} 

리턴 타입을 위해  decltype(x+y) 사용 불가

auto gt*int x, foat y) -> double 형

auto 이용

