# 함수의 활용

## c++ 인라인 함수

프로그램의 실행속도를 높이기 위해 c++에서 보강된 것.

일반함수와 인라인 함수의 큰 차이는 컴파일러가 코드를 프로그램이 어떻게 결합하느냐에 있음

이해하려면 내부구조 알아야됨.



컴파일 작업의 최종 산출물은 기계어 명령으로 이루어진 실행 프로그램.

프로그램 실행 -> 운영체제는 명령들을 컴퓨터의 메모리에 로드-> 로드된 명령은 특정 메모리 주소를 가짐.

컴푸터는 명령들을 순차적으로 실행



루프나 분기문 만나면, 프로그램은 앞이나 뒤의 특정 주소로 점프하여 명령들을 건너뜀.

일반적인 함수의 호출은 프로그램을 그 함수의 주소로 점프 시켰다가, 함수의 처리가 종결되면 다시 원래자리로 돌아옴.

함수 호출 명령에 도달했을 때, 그 함수 명령 다음에 있는 명령의 주소를 메모리에 저장 -> 스택에 매개변수 복사-> 그 함수가 시작되는 메모리 위치로 점프

> 그 함수 실행 -> 리턴 값 레지스터에 복사 -> 저장해둔 주소의 명령으로 돌아옴.

앞뒤로 점프 수행. 점프 위치 기억하려면 함수를 사용하는 데 시간이 많이 걸림.

c++인라인 함수가 이 문제 해결

컴파일러가 함수 호출을 함수코드로 대체

점프 필요 x 

메모리 측면에서는 불리

함수 코드를 수행하는 데 걸리는 시간이 매우 짧은 경우에만 인라인 함수가 시간 더 절약

사용은 함수 선언 앞에 inline 

함수 정의 앞에 inline

인라인 함수는 재귀 x



## 참조 변수

참조는 미리 정의된 어떤 변수의 실제이름 대신 쓸 수 있는 대용 이름

참조를 매개변수로 사용 시 원본 데이터로 작업가능

클래스 설계할 때 이용됨.

### 생성

int rats;

int &roodents = rats //rats의 대용 이름

이 둘은 모두 같은 값과 같은 메모리 위치 참조

&rats == &roodents

포인터랑 다른 점은 참조 변수는 선언하는 동시에 초기화 해야함.

int bunnies = 50;

roodents = bunnies;

roodents, rats의 값은 50이 되고, roodents는 여전히rats



int rats = 101;

int *pt = &rats;

int &roodebnts = *pt;

int buunies = 50;

roodents는 여전히 rats 참조

### 함수 매개변수 로서의 참조

주로 함수의 매개변수로 사용 됨.

- 참조를 전달하는 함수, 포인터 함수 비교

void swapr(int &a, int &b);

void swapp(int *a, int *b);

1. 매개변수가 선언되는 방식

2. 포인터를 이용하는 경우, *사용하여 원본에 접근



### 특성

double cube(double a){

a *=a;

return a;

}

double refcube(double &a){

ra *= ra;

return ra;

}

cube()는a를 변경해도 main()에 있는 변수에 영향 x

refcube()는 영향을 줌

cube(x+3.0); // 가능

refcube(x+3.0); //불가능

최신 c++에서는 에러

가끔 아닌 경우도 있음

이런 경우 에는,

이름 없는 임시변수를 만들어, x+3.0 의 값으로 초기화 함.

ra는 그 임시변수에 대한 참조가 됨.

최근 c++는 매개변수가 const참조 일 경우 에만 이것을 허용

참조매개변수가 const일 경우, 다음 상황에서 임시 변수 생성

-실제 매개변수가 올바른 형태, lvalue가 아닐때.

(lvalue 매개변수는 참조가 가능한 데이터 객체. 일반 상수, 여러 개의 항으로 이루어진 표현식은 lvalue가 아님)

- 실제 매개변수가 잘못된 데이터 형이지만, 올바른 데이터 형으로 변환 가능 할때



swap을 목적으로 하는 함수에서 임시변수 사용하면 서로 값이 변경아 안됨.

임시 변수들의 값을 서료 교환하기 때문



가능하면 const사용이 좋음.

1. 실수로 데이터 변경을 일으키는 에러 막을 수 있음.

2. 원형에 const사용 시 const와 const가 아닌 실제 매개변수 처리 가능. 생략시 const가 아닌 데이터만 처리 가능.

3. const참조 시 함수가 자신의 필요에 따라 임시 변수 생성하여 사용가능.

### 구조체에 대한

참조는 구조체나 클래스 다루는 데 유용

-전통적인 리턴, 참조 리턴 차이

전통적인 리턴은 함수가 종료되면 리턴에 의해 그 값은 다시 호출한 함수로 전달됨.

이 값은 임시장소에 복사되고 호출 프로그램은 이 값 사용

참조 리턴시 주의점

함수가 종료할 대 수명이 함께 끝나는 메모리 위치에 대한 참조를 리턴하지 않도록



이 문제 피하는 간단한 방법 : 매개변수로 전달된 참조 리턴

### 참조 매개변수는 언제 사용 하는지

1. 호출 함수에 있는 데이터 객체의 변경을 허용

2. 프로그램 속도 향상 위해



함수가 데이터를 사용만 하는 경우

1. 기본 데이터형, 작은 구조체는 값으로 전달

2. 데이터 객체가 배열이면 포이터가 유일한 선택.

const를 지시하는 포인터

3. 큰 구조체 라면 const포인터, const참조 사용. 시간과 공간 절약

4. 클래스 객체이면 const 참조 사용



함수가 데이터 변경하는 경우

1. 기본 데이터형이면 포인터 사용

2. 배열이면 포인터 사용

3. 구조체는 참조나 포인터

4. 클래스는 참조 사용


