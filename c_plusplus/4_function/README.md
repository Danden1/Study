# 함수

### 함수 원형

- 함수 원형이 필요한 이유

함수원형은 컴파일러에게 함수의 인터페이스를 알려줌.


1. 어떤 타입의 매개변수를 갔는지 컴파일러에게 알려줌

2. 리턴 값을(cpu의 레지스터나 메모리)어떤 지정된 위치에 넣는다. 호출한 함수가 그 위치에서 값을 꺼냄.

  타입을 함수원형이 알려주므로, 몇 바이틀르 꺼내고, 처리해야 할 지 알수 있음.


## 함수, 배열


### 배열을 매개변수로 사용한느 것의 의미

int sum_arr(int arr[], int n);

sum_arr(ar,size);

ar배열의 첫 번째 주소와 배열원소 개수를 전달.

배열이 어디에 있는지(주소), 데이터 형을 함수에 전달하는 것임.

함수는 배열의 원본에 접근 가능.

### const로 보호

함수가 배열의 원본을 변형 시킬 수 있음.

배열인 매개변수에 const를 붙이면, 변경이 불가능

### 배열의 범위를 사용하는 함수

매개변수로 배열을 쓸 경우, size도 같이 매겨변수로 준다.

다른 방법은 배열의 시작을 지시하는 포인터와 배열의 끝을 지시하는 포인터를 전달.

### 포인터와 const

int age = 39;

const int * p = &age;

포인터 p를 사용하여 값을 변경 불가.

age를 사용해서는 변경 가능.

const int age = 10;

int *cp = &age; //불가능

사용하려면 포인터도 const사용

그러나 새로운 주소는 대입 가능.

이것을 막으려면,

int *const p2 = &age;

이용, 그러나 값은 변경 가능

const int *const p2 = &age;

둘다 변경 불가능.



## 함수, 2차원 배열

int data[3][4] = {0};

int total = sum(data,3);

int sum(int (*ar2)[4], int size);// int ar2[][4] 도 사용 가능




ar2[r][c] == *(*ar2 +r) +c) //true

ar2 // 첫번째 행(int 4개 배열)을 지시하는 포인터

ar2 +r //r번째 행 지시하는 포인터

*(ar2+r) //  ar2[r], r번째 행의 첫번째 int지시

*(ar2+r)+c // ar2[r]+c

그리고 const를 사용하지 않았음. ar2는 포인터를 지시하는 포인터

기본형을 지시한 포인터에 대해서만 const사용가능
