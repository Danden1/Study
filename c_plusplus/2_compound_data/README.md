# 복합 데이터 형

## 문자열

cin은 빈칸, 탭 등이 있으면 그 위치에서 문자열이 끝난 것으로 간주함.

ex)

char name[6];

cin >> name; //Ali Dr

Ali\0을 name배열에 저장

Dr은 입력 큐에 남겨짐. 만약 cin이 또 호출되면, Dr이 저장됨.

### 한번에 한 행의 문자열 

1. getline()

Enter키에 의해 전달되는 개행 문자를 입력의 끝으로 간주, 한 행 전체를 읽음.

첫 번째 매개변수는 배열의 이름, 2번 째는 크기(널문자 포함)

cin.getline(name,6);



2. get()

개행문자를 입력 큐에 담아둠.

cin.get(name,6);

cin.get(); //문자열 하나를 읽음(개행문자)

cin.get(namm2,8);




## string 클래스

<string>헤더 파일을 포함 시켜야 됨.

sring 클래스는 std이름 공간에 속해 있음.

string str;

cin >> str; // str은 입력에 맞게 크기가 조절 됨.

하나의 string 객체를 다른 string 개체에 간단히 대입 가능

한행을 입력 받으려면, getline(cin,str);



## 공용체

서로 다른 데이터 형을 한 번에 한 가지만 보관 가능한 데이터 형식

ex)

union one4all{

int int_val;

double double_val;

}

one4all n;

n.int_val = 10;

n.double_val = 1.1; //double형을 저장, int형 값 소실

한 번에 하나의 값만 보관가능. 공용체의 크기는 가장 큰 멤버의 크기

## 열거체

c++의 enum은 const를 사용하여 기호 상수를 만드는 것에 대한 또 다른 방편 제공.


ex) enum spec {red, orange. yellow, green}

-spec을 새로운 데이터 형의 이름으로 만듬. 열거체 라고 부름

- red.. 등을 0~3까지의 정수 값을 나타냄. 상수들을 열거라잘고 함

열거체 변수에는 열거자 값들만 대입가능

대입 연산자만 사용가능. 산술 연산 x



대입 연산자를 사용하여 열거자의 값을 명시적으로 지정 가능.

ex) enum {first, second = 100, third}

first = 0, third = 101이 됨.

int형만 대입이 가능했지만, 지금은 long형도 가능

각 열거체는  범위를 가짐.

어떤 정수값이 그 범위 안에 있으면, 열거자 값이 아니라도 대입가능.

범위는 열거자 값중 최댓값보다 큰 2의 제곱수를 구하고 -1 한것.

최소값이 0, 양수이면 범위값은 하한은 0, 음수는 상한을 구하는 법이랑 동일



## 포인터, 메모리 해제

### 포인터 위험

c++에서 포인터 생성시, 컴퓨터는 주소를 저장하기 위한 메모리 대입.

long* fel;

*fel = 223323; // 어딘지 알 수 없는 곳에 값 저장

fel이 어디를 지시하는 지 알 수 없음.

fel 은 초기화 되지 않아서, 엉뚱한 값이 들어 있음.

그 값은 23323을 지정함.

반드시 초기화를 해줘야 함.



### 포인터와 수

포인터에 정수 직접 대입 불가. 

(int*)같이 형 변환을 해야됨.

### new를 사용한 메모리 대입

c++에서는 new를 이용해 이름이 없는 메모리에 대입 가능.

어떤 데이터형의 메모리를 원하는지 new연산자에게 말해주면, 그에 알맞은 메모리 블록을 찾아내고, 그 블록의 주소를 리턴



ex)

1. int* pn = new int;

2. int n;

int *pt = &n;



2는 pt가 아닌 n을 통해서도 접근 가능.

1은 pn을 통해서만 접근 가능



메모리가 부족하면 new는 0을 리턴, 값이 0인 포인터를 널 포인터라고 부름

### delete를 사용한 메모리 해제

int* ps = new int; //메모리 대입

delete ps; //메모리 해제



ps가 지시하는 메모리가 해제 됨

ps는 새로 대입한 메모리를 지시하는 데 다시 사용 가능

메모리 누수가 발생할 수 있기 때문

### new를 사용한 동적 배열의 생성

거대한 데이터 다룰 때는 new가 효율적

int* p = new int[10];

new연산자는 그 블록의 첫 번째 원소의 주소 리턴.

delete[] p;



- new로 대입하지 않않은 메모리는 delete로 해제 불가

- 같은 메모리 블록을 연달아 delete로 해제 x

- new[], delete[]로 해제

- 널 포인터에는 delete 사용이 안전.

동적 배열의 크기를 알려고 sizeof()사용 불가(나중에 다시 한 번 나옴)

값에 접근할 때는 배열 처럼 사용

p = p+1;

을 하면 p[0]의 값은 p[1]이 됨.

+1은 그 다음 차례의 원소를 가리키게 됨.

## 포인터, 배열, 포인터 연산

포인터 변수에 1을 더하면, 그 포인터가 지시하는 데이터 형의 바이트 수만큼 증가

배열에 sizeof를 쓰면 배열의 크기가 나오지만, 포인터는 포인터의 크기가 나옴.



### new를 사용한 동적 구조체의 생성

inflatable* ps = new inflatable;

동적 구조체에는 .연산자 사용 불가

동적 구조체에는 이름이 없기 때문.

.대신 -> 사용

ex)

struct things{

int good;

int bad;

}

things gb = {3,4};

things* pt = &gb;

//pt->good == 3, gb.good == 3

->대신 (*pt).good 도 사용가능(지저분한 방식)


### 자동, 정적, 동적 공간

c++에서 데이터를 저장해 두기 위한 메모리를, 대입 방법에 따라 구분함. 동적공간은 heap이라고도 함.



1. 자동 공간

함수 안에서 정의되는 보통의 변수들(자동 변수)가 사용.

함수가 호출 될 때 생성되고, 종료되면 사라짐.



자동 변수는 자신들을 포함하고 있는 블록({})안에서만 유효

스택에 저장됨. 메모리 상의 스택에 순차적으로 저장되고, 역순으로 해체됨.(LIFO)

따라서 프로그램이 실행되는 동안 늘었다, 줄었다를 반복.


2. 정적 공간

프로그램이 실행되는 동안 지속적으로 존재한느 공간.'

만드는 방법은 함수의 외부에 변수를 정의하거나 static을 이용해 변수 선언하면 됨.

3. 동적 공간

new, delete는 자유공간이라 부르는 메모리 풀을 관리. 이 풀은 자동 벼수라 정적변수가 사용하는 메모리와 분리되어 있음. new, delete를 사용하면 메모리에 대해 강력한 제어권을 가질 수 있음


포인터는 c++에서 가장 강력한 도구



## 배열의 대한

### vector 탬플릿 클래스

프로그램이 실행되는 동안 vector객체의 크기를 세팅할 수 있고, 새로운 데이터를 마지막에 추가하거나, 중간에 삽입가능.

메모리를 관리하기 위해 new, delete를 사용하지만, 그 과정은 자동

vector헤더 파일을 포함시켜야 됨.

std이름 공간의 일부임

ex)

#includet <vector>

using namespace std;

vector <int> vi; //int의 0사이즈 배열

int n;

cin >> n;

vector<double> vd(n); //n개의 더블 배열 생성



### array 탬플릿 클래스(c++11)

내재 배열과 동일한 수준의 효율성

array 헤더파일 필요

array<int,5> ar; //5개의 int

2번재 인자에 변수는 못옴


### 배열, vector, array 비교

1. 전부 표준 배열 표식 사용 가능

2. 주소를 통해 array가 동일한 지역의 메모리 사용(stack)

vector는 다른 지역(heap)

3. array객체를 또 다른 array객체에 할당
