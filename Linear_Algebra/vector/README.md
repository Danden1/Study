# 벡터


'운반하다'라는 뜻의 라틴어에서 유래됨.

어떤 것을 한 장소에서 다른 곳으로 이동하는 벡터의 방향성에서 비롯됨.

벡터를 숫자 등의 리스트라고 생각해면 됨.

def: 4개의 실수를 원소로 가지는 벡터를 r상의 4-벡터라고 함.



## 벡터는 함수이다.

def: 유한 집합 D와 필드 F에 대해. F상의 D-벡터는 D에서 F의 함수임.



컴퓨터 과학자들이 사용하는 정의임.

자료구조를 표한하는 데 적합함.

수학자들이 사용하는 정의와 달리 중요한 다른 점이 2가지 있음.

- 정의역 D는 유한함. if D가 무한하면 , 성립하지 않는 정리가 있음.

- 선형대수학에 대한 전통적인 추상적 접근법들은 벡털르 직접적으로 정의하지 않음.



### 딕셔너리를 이용한 벡터 표현



벡터는 유일한 정의역을 가지는 함수.

딕셔너리는 이렇나 함수를 표현하는 데 사용함.



### Sparsity 

대부분의 원소값이 0인 벡터를 스파스(sparse)벡터라고 함. 0이 아닌 원소의 수가 최대 k개인 벡터는 'k-스파스'라고 함.



## 벡터로 표현 가능 한 것.



- 이진 문자열

n-비트 이진 문자열 10111011 ex)어떤 암호의 비밀키는 GF(2)상의 n-벡터 [1,0,1,1,1,0,1,1] 에 의해 표현 될 수 있음.



- 속성

ex) Jan = {'age': 20, 'income' : 850}

- 확률 분포

{1:1/6, 2:1/6, 3:1/6, 4:1/6, 5:1/6 ,6:1/6}

- 이미지

1024x768의 흑백 이미지는 쌍들의 집합 { (i,j) : 0 <= i <1024, 0<= j <768}에서 실수로의 함수로 볼 수 있고, 벡터로 볼수 있음.

(i,j)는 픽셀 (i,j)의 밝기라고 부르는 숫자로 매핑됨.

- 공간상의 점

벡터를 사용하여 평면, 3차원 .... 에 있는 점들을 나타냄.



## 벡터의 덧셈



### 평행이동과 벡터 덧셈

f(v) = v0 + v

def : n-벡터들의 덧셈은 대응하는 원소들의 덧셈으로 정의됨.

def : add2(v,w):         return [v[0]+w[0], v[1] + w[1]]

결합법칙과 교환법칙이 성립됨.

## 스칼라 - 벡터 곱셈



벡터에서 필드원소는 스칼라라고 불림.

곱셈을 통해 스케일링 가능.

def : 벡터 u와 스칼라 a의 곱셈은 u의 원소 각각을 a와 곱하는 것으로 정의됨.

### 화살표 스케일링

양의 실수로 스케일링 하는 것은 벡터의 방향을 바꾸지 않고, 화살표의 길이를 변경함.

음의 실수를 곱하면 화살표의 방향이 변하게 됨.

### 결합성

a(bv) = (ab)v  // v는 벡터, a,b는 스칼라

### 원점을 지나는 직선

v= [3,2]

스칼라들의 집합 a는 {0,0.1....1.0} 이라고 하면,

av는 v보다 약간 작지만 같은 방향을 가리키는 벡터임.

{av : 0<= ㅁ <=1} (a는 실수)

이면 어떤 선분이 생성됨.



## 벡터 덧셈과 스칼라 곱셈 결합

{a[3,2] + [0.5,1] : 0<=a<=1}

이면 x는 +0.5, y는 1만큼 평행이동



### 분배 법칙

a(u+v) = au+ av

(a+b)v = av+bv

### 블록 결합 (convex combination)

[0.5,1]와 [3.5,3]을 잇는 선분을 이루는 점들의 집합에 대한 표현식은 {a[3,2] + [0.5,1] : 0<=a<=1}임

a[3,2] + [0.5+1] = a([3.5,3] - [0.5,1] +[0.5,1]

= a[3.5, 3] -a[0.5,1] + [0.5,1]

=a[3.5, 3]- (1-a)[0.5,1] = a[3.5, 3] - b[0.5,1]

b = 1-a, a,b>=0

av+bv 형태의 표현식은 u와 v의 블록 결합이라고 함.



### 아핀 결합(affine combination)



무한한 직선을 그림. 블록결합에서 음수도 포함함.

## 딕셔너리에 기반들 둔 벡터 표현

예제파일 vec_ex.py참조 



## GF(2) 상의 벡터

1101 + 0111 = 1010

ex)

10벡터 k를 랜덤 선택 p는 평문. c는 암호문

c = p+k(벡터의 덧셈)

p = c-k

c에다 k를 더하면 암호문 해동이 가능. => 뺄셈은 덧셈이랑 동일함.

이를 이용하면 p,k를 다른 서버에다 저장하면, 하나의 서버만 공격해서는 비밀번호를 알 수 없음.

## 도트곱

D- 벡터를 u,v라 하면,

u'v = u1v1 + u2v2... +unvn

연산의 결과는 스칼라임

def list_dot(u,v) :return sum([v[i]+u[i] for i in range(len(u))])

### 선형 방정식

def 선형방정식(일차 방정식)은 a'x = b의 형태를 가지는 식

a= 벡터, b는 스칼라, x는 벡터 변수

ex)센서 노드의 에너지 사용률

D = {rade, sensor, momory, cpu}

rate = Vec (D, {memory : 0.06w, radio : 0.1w, sensor : 0.004w, cpu : 0.0025w}

duration = Vec(D, {momory : 1.0, radui : 0.25, sensor : 0.5, cpu : 1.05})

센서 노드에 의해 소모된 총 에너지는 duraton'rate = 0.0845j


### 유사성 측정

도트곱은 r상의 벡터들 사이의 유사성을 측정하는 데 사용 가능

ex1> 투표기록 비교

정의역 D는 상원 의원이 투표한 법안들의 집합

각 상원의원은 벡터로 표현, 이 벡터는 법안을 {+1,0,-1}에 맵핑, 찬성, 반대, 기권임.

두 명의 의원의 도트곱을 해서 양수이면 대체로 의견이 일치, 음수이면 일치하지 않음을 나타냄

ex >2 오디오 세그먼트 

짧은 오디오 클립이 있는데, 이것이 긴 오디오 세그먼트에 나타나는지 검색

오디오 세그먼트는 시간에 대한 연속함수(파형)



두 개의 길이가 같은 긴 오디오 세그먼트 비교

비교하는 단순한 방법은 벡터의 도트곱셈.

v[i],u[i]가 동일한 부호를 가지면 값이 더욱 커짐(양수)

서로 일치하는 정도가 크면 값이 커짐.

ex) 긴 세그먼트 [1,-1,1,1,1,-1,1,1,1]

짧은 클림은 [1,-1,1,1,-1,1]

도트 곱은 [2,2,0,0]따라서 1번째 또는 2번째위치.

그러나 [1,2,3,4,5,6], [1,2,3]에서는 안됨.

def dot_product_list(needle, haystack):         s = len(needle)         return [dot(needle, haystack[i:i+s]) for i in range(len
(haystack)-s)]

다른 방법은 짧은 클립을 0으로 패딩해서 긴 벡터로 만들어서 도트곱을 하는 것.

선형 필터를 적용한 예임

### GF(2)상의 벡터들에 대한 도트곱

ex) 11111+10101 = 1+0+1+0+1 = 1

1의 개수가 짝수이면 0, 홀수이면 1이 됨.

### Parity bit

데이터를 저장하고 전송할 때 에러 발생 가능

에러 검출에 사용되는 가장 기본적인 방법은 패리티 비트임.

n-비트 시퀀스를 신뢰할 수 있게 전송하기 위해, n-비트 시퀀스의 패리티 비트를 계산하여, n-비트 시퀀스와 함께 보냄.

### 도트곱의 대수적 성질

어떤 필드에서든 성립함

교환성 u-v = v-u

동질성 (av)u = (a(uv))

분배성 (u+v)w = uw + vw

## 선형방정식들의 삼각시스템에 대한 해 구하기

### 상삼각 시스템

[a11,a12,a13 ... a1n]x = b1

[a21,a22,a23.... a2n]x = b2

[0,0,0... ann]x = bn

이런 형태를 가짐

-첫 번째 벡터는 0을 가지지 않아도 됨.

-두 번째 벡터는 첫 번째 위치의 값이0

- 세번째 비트는 첫 번째, 2번째 위치의 값이 0

-  n번째 비트는 n번째 엔트리 이외에는 모두 0

### 후진 대입법

n번째 변수의 값부터 구함.

이걸 차례대로 대입해서 값을 구함.

### 구현

벡터와 도트곱을 사용하여 표현가능

x를 원소가 모두 0인 벡터로 초기화. 마지막 엔트리에서 시작하여 x의 각 엔트리를 채워 나감.

aii' xi 의 값 = bi - (값을 알고 있는 변수들이 포함된 표현식)

xi = (b1 - (값을 알고있는 변수들이 포함된 표현식))/aii

    labellist = {'a','b','c','d'}        
    
    D = set(labelist)
    
    rowlist = [Vec(D, {'a' : 4, 'b' : -2, 'c': 0.5, 'd': 1}),Vec(D, {'b' : 2, 
    
    'c': 3, 'd': 3}),Vec(D, {'c': 5, 'd': 1}),Vec(D, {'d': 2})
    
    b = [6,-4,3,-8]
    
    def triangular_solve(rwolist, labellist, b):
    
      D = rowlist[0].D
      
      x = zero_vec(D)
      
      for j in reversed(range(len(D))):
        
        c = labellist[j]
        
        row = rowlist[j]
        
        x[c] = (b[j]-x*row)/row[c]
        
      return x




