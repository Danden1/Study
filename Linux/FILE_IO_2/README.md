## 벡터 입출력

### readv(),  writev()

    #include <sys/uio.h>
    
    ssszie_t readv(int fd, const struct iovec *iov, int cout);

fd 에서 데이터를 읽어서 count 개수 만큼의 iov 버퍼에 저장.

    #include <sys/uio.h>
    
    ssize_t writev (int fd, const struct iovec *iov, int count);

count 개수 만큼의 iov버퍼에 있는 데이터를 fd에 기록.

read()와 write()와 동일하게 작동 하지만, 여러개의 버퍼를 사용 한다는 점에서 구분됨.


    #include <sys/uio.h>
    
    struct iovec{
    
    void *iov_base; /* 버퍼의 시작 포인터 */
    
    size_t iov_len; /* 버퍼크기*/
    
    };

호출이 성공 했을 때 읽거나 쓴 바이트 개수를 반환. 반환값은 반드시 count * iov_len 값과 같아야됨. 에러 -1 반환



## 메모리에 파일 맵핑하기

리눅스 커널은 표준 파일 입출력의 대안으로 애플리케이션이 파일을 메모리에 맵핑할 수 있는 인터페이스 제공.

개발자는 메모리에 상주하는 데이터처럼 메모리를 통해 파일에 직접 접근 가능.

맵핑된 메모리 주소에 직접 쓴느 것만으로 디스크에 있는 파일에 기록 가능.

### mmap()


    #include <sys/mman.h>;                    
    
    void *mmap(void *addr, size_t len, int prot, int falgs, int fd, off_t offset);
    
    
fd가 가리키는 파일의 offset 위치에서 len바이트 만큼 메모리에 맵핑하도록 커널에 요청.

addr이 포함되면 메모리에서 해당 주소를 선호한다고 커널에 알려줌.

접근 권한은 prot에 지정, 추가적인 동작은 flag에 명시

addr인자는 대부분 0을 넘김.

메모리 맵핑의 실제 시작 주소를 반환함. 실패시 MAP_FAILED 반환

prot

PROT_NONE : 접근이 불가능한 페이지.

PROT_READ : 읽기가 가능한 페이지.

PROT_WRITE : 쓰기가 가능한 페이지.

PROT_EXEC : 실행이 가능한 페이지.

flag

MAP_FIXED : mmap()의 addr인자를 요구사항으로 취급.(0 안됨.) 해당 주소를 확보하지 못하면 실패. 기존 맵핑과 겹칠 경우, 중첩된 페이지는 새로운 맵핑으로 대체.

MAP_PRIVATE : 맵핑이 공유되지 않음을 명시. 

MAP_SHARED : 같은 파일을 맵핑한 모든 프로세스와 맵핑을 공유. 맵핑된 페이지에 쓰기를 하면, 실제 파일에도 동일한 내용을 기록.

MAP_SAHRED 와 MAP_PRIVATE를 함께 지정하면 안 됨.

파일을 맵핑 한 후에 파일 디스크립터를 닫더라도 프로세스는 여전히 맵핑된 주소에 접근 가능.


### 페이지 크기

페이지는 메모리 관리 유닛에서 사용하는 최소 단위.

mmap은 페이지를 다룸.

len인자가 페이지 크그 단위로 정렬되지 않았다면 다음 크기의 페이지 정수배로 확장됨.

### mmunmap()

    #include <sys/mman.h>
    
    int munmap(void *addr, size_t len);

mmap()으로 생성한 맵핑을 헤제.

성공시 0반환, 실패시 -1
    
    
    

### 맵핑 크기 변경하기

    #define _GNU_SOURCE        #include <sys/mman.h>        void *mremap(void *addr, size_t old_size), size_t new_size, unsigned long flags);

[addr, addr+old_size)에 맵핑된 영역을 new_size만큼의 크기로 변경.

커널은 프로세스의 주소 공간에서 사용 가능한 공간과 flags 값에 따라 맵핑된 위츨 변경 가능.

flags 인자는 0 이거나, MREMAP_MAYMOVE] 가능. 후자는 크기 변경 요청을 수행하는 데 필요하다면 맵핑의 위치를 이동해도 괜찮다고 커널에 알려줌.

성공시 크기가 조정된 메모리 맵핑의 시작 주소 반환, 실패시 MAP_FAILED 반환.


### 맵핑의 보호 모드 변경


    #include <sys/mman.h>        int mprotect (const void *addr, size_t len, int prot);


[addr, addr+len)영역 내에 포함된 메모리 페이지의 보호 모드 변경. 리눅스에선느 어떤 메모리 영역에도 사용가능.

성공시 0, 실패시 -1


### 파일과 맵핑의 동기화


    #include <sys/mman.h>        int msync(void *addr, size_t len, int flags);

mmap()으로 맵핑된 파일에 대한 변경 내용ㅇ르 디스크에 기록하여 파일과 맵핑을 동기화 함.

addr 인자는 반드시 페이지 크기로 정령되어야 함. 보통은 mmap()에서 반환값을 이용.

flag는 동기화 방식을 젲어.

MS_SYNC : 디스크에 모든 페이지를 기록하기 전까지 반환하지 않음.

MS_ASYNC : 비동기 방식으로 제어. 갱신작업은 예약되고, 디스크에 페이지가 기록될 때까지 기다리지 않고 즉시 반환.

MS_INVALIDATE : 맵핑의 캐시 복사본을 모두 무효화함. 

MS_SYNC나 MS_ASYNC 중 하나는 반드시 지정해야되지만, 같이 사용은 불가능.


### 맵핑의 사용처 알려주기

    #include <sys/mman.h>        
    
    int madvise(void *addr, size_t len, int advice);

addr로 시작해서 len바이트의 크기를 가지는 메모리 맵핑 내의 페이지와 관련된 동작 방식에 대한 힌트를 커널에 제공

len이 0이면, 커널은 addr에서 시작하는 전체 맵핑에 힌트 적용.



advice 인자

MADV_NORMAL : 평상시와 마찬가지로 동작.

MADV_RANDOM : 미리읽기 사용 안함. 물리적인 읽기 과정에서 최소한의 데이터만 읽어옴.

MADV_SEQUENTIAL : 공격적으로 미이릭기 수행.

MADV_WILLNEED : 커널이 미리읽기를 활성화, 주어진 페이지를 메모리로 읽어 들임.

MADV_DONTNEED : 페이지와 관련된 자원을 해제하고 변경되었지만 아직 동기화 되지 않은 페이지를 버림.    
                이후 맵핑된 데이터에 접근이 발생하면 연관된 파일로부터 페이지의 내용을 채우고, 연관된 파일이 없는 익명 맵핑인 경우에는 요청받은 페이지를 0으로 채움.

MADV_DONTFORK : 프로세스를 포크할 때 자식 프로세스에 해당 페이지가 복사되지는 않도록 함.

MADV_DOFORK+ : MADV_DONTFORK 의 동작방식을 원래래도 되돌림.

성공시 0, 실패시 -1 반환


## 입출력 스케줄러와 성능

디스크와 시스템의 나머지 부분 간의 상대적인 성능차이가 상당히 큼.

디스크의 성능을 가장 심각하게 떨어뜨리는 부분은 탐색이라고 하는 하드 디스크에서 데이터를 읽고 쓰는 헤드를 이동시키는 과정임.

하드 디스크와 나머지 시스템 간의 성능상의 차이 때문에 입출력 요청을 순서대로 디스크로 보내는 방식은 효율적이지 못함.

입출력 스케줄럴르 구현해서 입출력 요청의 순서와 시간을 조작하는 방법으로 디스크 탑색 횟수를 최소화함.


### 디스크 주소 지정방식

CHS(cylinder, head, sector)주소 지정 방식을 사용.

특정 데이터가 저장되어 있는 디스크의 위치를 찾을 때 하드 디스크는 실린더, 헤드, 섹터값을 필요로 함.

실린더 값은 데이터가 위치한 트랙, 헤드 값은 요청한 읽기/쓰기 헤드의 정확한 값을 구분함, 섹터 값을 사용해서 트랙에 위치한 정확한 섹터를 찾ㅈ음.

하드 디스크는 데이터를 찾기 위해 어떤 플래터의 어느 트랙, 어느 섹터에 데이터가 있는 지 알아야 함.


### 입출력 스케줄러의 동작 방식.

병합과 정렬이라는 두 가지 기본 동작을 수행함.


병합은 둘 이상의 인접한 입출력 요청을 단일 요청으로 합치는 과정. 

ex) 하나는 5번, 다른 하나는 6~7 번까지 블록을 읽으려 하면, 5~7번을 읽는 하나의 요청으로 합침.

정렬은 병합보다 더 중요.  대기 중인 입출력 요청을 블록 순서의 오름차순으로 정렬.

ex) 52,109,7에 대한 입출력 연산이 들어오면, 7,52,109 순서대로 정렬함.

이런 방식을 통해 디스크의 헤드 움직임을 최소화 함.


### 읽기 개선

요청한 데이터가 페이지 캐시에 존재하지 않으면 디스크에서 데이터를 읽어올 때까지 블록되어야 하며 이는 시간이 오래 걸릴 수 있는 작업임.

=> 이런 성능 영향ㅇ르 읽기 레이턴시(latency)라고 함.


쓰기 요청은 디스크 성능에 방해가 되지 않느 스트림을 사용. 쓰기 스트림은 커널과 디스크의 주의를 독차지 할 수 있으므로 이런 스트리밍 동작방식은 읽기문제만 복잡하게 됨.

=> 이런 현상을 쓰기가 읽기를 굶겨 죽이는 문제라고 함.


입출력 스케줄러가 항상 요청이 들어온 순서에 따라 새로운 요청을 끼워넣는다면 멀리 떨어진 블록에 대한 요청을 무기한으로 굶겨 죽일 수 있음.

ex) 50번 블록에 대한 새로운 요청이 끊임없이 들어오면 109번 블록에 대한 요청은 절대 처리하지 못할 것임.

입출력 스케줄러는 이런 굶겨 죽이는 사태를 방지 할 수 있는 메커니즘을 도입하고 있음.

리눅스 2.4 커널의 입출력 스케줄러에서 채택한 리누스 엘리베이터 같은 단순한 접근 방식은 큐에 충분히 오래된 요청이 있다면 삽입-정렬기능을 멈춤.

전체 성능을 희생하여 요청에 대한 공정성을 유지하고 읽기 요청일 경우 레이턴시를 개선함.

문제는 이 휴리스틱이 너무 단순함.

리눅스 커널 2.6에서는 리누스 엘리베이터를 사용하지 않고 몇 가지 새로운 입출력 스케줄러를 공개함.




### 데드라인 입출력 스케즐러

리누스 엘리베이터는 대기 중인 입출력 요청을 정렬된 목록으로 유지.

큐의 제일 앞에 위치한 입출력 요청은 다음에 처리 할 요청임.

데드라인 입출력 스케즐러는 이 큐를 유지하고 거기에 읽기 FIFO 큐와 쓰기 FIFO 큐라는 두가지 추가 큐를 도입하여 문제를 해결함.

각 큐에 있는 아이템은 큐에 들어온 시간에 따라 정렬됨.(먼저 들어온 아이템이 먼저 나감.)

읽기 FIFO큐는 읽기 요청만 담고 있고, 쓰기는 쓰기 요청만 담고 있음.

들어 있는 각 요청은 만료기간이 할당 되있음.

읽기는 500밀리 초, 쓰기는 5초의 만료기간이 설정 되어 있음.



새로운 임출력 요청이 들어오면 표준 큐에 삽입, 정렬되고 읽기 혹은 쓰기 FIFO큐의 끝 부분에 위치함.

보통 정렬된 표준 큐의 앞부분에 있는 입출력 요청을 하드디스크로 보냄.

리누스 엘리베이터와 마찬가지로 표쥰 큐가 블록 번호로 정렬되어 있으므로 탐색을 최소화하여 전체 처리량을 최대로 높임.



FIFO큐 앞부분에 있는 아이템이 해당 큐의 만료기간보다 오래되면 입출력 스케줄러는 표준 큐에서 입출력 요청을 처리하지 않고 해당 FIFO큐에서 처리를 시작함.


데드라인 입출력 스케줄러는 오랜 시간 동안 요청을 굶겨 죽이지 않은 채로 전체 처리량을 달성 가능.



### 예측 입출력 스케줄러


데드라인 입출력 스케줄러는 연속된 읽기 요청중 첫 번째 요청을 만료시간 내로 처리한 다음, 정렬된 큐에서 입출력 요청을 처리하기 위해 돌아옴.

애플리케이션에서 또 다른 읽기 요청을 몰아서하면, 만료시간이 다가오고 입출력 스케줄러가 디스크에 요청을 보내면 바로 요청을 처리하기 위해

탐색을 수행, 그 후에 정렬된 큐의 요청을 계속 처리하기 위해 또 탐색을 함. 이렇게 왔다갔다 탐색작업을 하는 이유는 대부분 애플리케이션이 이렇게 동작하기 때문.

읽기 요청이 계속해서 들어오고 디스크가 이를 처리하기 위해 앞뒤로 계속 왔다 갔다 해서 전체 처리량은 그다지 좋지 못함.

또다른 문제점은 새로운 읽기 요청은 앞선 요청이 반환되어야만 처리 됨. 

애플리케이션이 읽은 데이터를 받기까지 스케즐러는 계속 동작하고 다음 읽기 요청을 제출하면 입출력 스케즐러는 다른 요청을 처리함.

매번 데이터를 읽을 때마다 데이터를 읽어서 서비스 하는 데 한 번, 다시 되돌리는데 한번, 총 두번의 탐색을 낭비함.

만약 입출력 스케즐러가 디스크의 동일한 위치에 대한 읽기가 곧 제출될 것이라는 사실을 알게 되면, 다음 읽기를 예측하고 기다릴 수 있음.

==> 이것이 예측 입출력 스케즐러가 동작하는 방식

데드라인 입출력 스케즐러로 시작하나, 예측 메커니즘을 추가하여 능력이 강화됨.

예측 입출력 스케즐러는 요청을 처리한 후 아무것도 하지 않고 6밀리 초까지 기다림.

기다리는 동안 새로운 요청이 들어온다면 해당 읽기 요청은 즉시 처리되고 예측 입출력 스케즐러느 좀 더 기다림.

기다리는 동안 더 이상의 읽기 교청이 없다면 예측 입출력 스케즐러는 표준 정렬 큐를 처리하는 것처럼 이전에 작업한 내용을 반환함.



### CFQ 입출력 스케줄러


CFQ를 사용하면 프로세스마다 독자적인 큐를 할당. 각 큐는 시간을 할당 받음.

라운드 로빈 방식으로 각 큐를 순회하면서 그 큐에 허락된 시간이 다 지나거나 요청이 더 이상 남아 있지 않을 때까지 그 큐에 있는 요청을 처리함.

시간이 남았지만 요청이 더이상 큐에 남아 있지 않은 경우 짧은 시간 동안 그 큐에 들어오는 새로운 요청을 기다림.

각 프로세스의 개별 큐 안에서 동기화된 요청은 동기화되지 않은 요청보다 좀 더 높은 우선순위를 갖ㅈ음.

읽기 요청을 배려하여 쓰기 요청이 읽기를 굶겨 죽이는 문제를 회피함.

프로세스 단위로 큐를 설정하기 때문에, 전체 성능을 좋게 유지하면서도 모든 프로세스에 공정하게 동작함.

대부분의 업무 부하에 적합함.


### NOOP입출력 스케줄러

사용 가능한 스케줄러 중 가장 기본적임.

기본적인 병합만 수행. 요청을 정렬할 필요가 없거나 정렬을 하지 않는 장치에 특화됨. SSD에 좋음.



## 사용자 영역에서 정렬


### 경로

가장 쉽지만 효과는 적은 방법. 블록 단위 정렬을 흉내내는 방식.

디스크에 있는 파일의 물리적인 위치를 얼추 비슷하게 맞출 수 있음. 같은 디렉터리에 존재하느 두 파일이 디스크에서 인접해 있을 확률이 ㄴ옾음.

이런 접근 방법의 단점은 파편화를 고려하지 않음. 파편화가 심할수록 파일 경로로 정렬하는 방법은 덜 유용함.

파일 경로 정렬은 실제 블록단위 순서의 근사값.

장점은 모든 파일 시스템에 적용 가능.

파일 배치에 어떤 방법을 사용하더라도 일시적인 지역성 덕분에 중간 정도의 정확도를 기대 할 수 있음.


### inode

파일의 데이터가 물리적은 디스크 블록 여러 개를 점유하고 있다 해도 파일은 하나의 inode만을 가짐.

모든 파일은 그 파일과 관계된 하나의 inode를 가지고 있고, inode는 유일한 번호가 할당됨.

파일 i의 inode 번호 < 파일 j의 inode 번호

같은 관계를 가정 할 때 파일 경로를 정렬하는 것보다 더 쉬움.

일반 적으로

i의 물리블록 < j의 물리블록

라는 의미를 내포함.

장점은 inode 번호는 쉽게 얻을 수 있고, 정렬하기 쉬움. 물리적인 파일 배치를 추측 할 수 있음.

단점은 파편화에 따라 추측이 틀릴 수 있고, 유닉스 파일 시스템이 아니면 정확도가 떨어짐.


### 물리 블록

자기만의 엘리베이터 알고리즘을 설게하기 위한 최적의 방법은 물리적은 디스크 블록으로 정렬 하는 것.

각 파일은 파일시스템에서 가장 작은 할당 단위인 논리 블록 단위로 쪼개짐.

논리 블록의 크기는 파일시스템마다 다름. 각각의 논리 블록은 하나의 물리 블록에 맵핑되어 있음.

파일이 차지하고 있는 논리 블록의 번호를 찾아내서 어떤 물리블록에 맵핑되어 있는지 확인하고 이를 기반으로 정렬하는 것.
