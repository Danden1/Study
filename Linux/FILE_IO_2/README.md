## 벡터 입출력

### readv(),  writev()

    #include <sys/uio.h>
    
    ssszie_t readv(int fd, const struct iovec *iov, int cout);

fd 에서 데이터를 읽어서 count 개수 만큼의 iov 버퍼에 저장.

    #include <sys/uio.h>
    
    ssize_t writev (int fd, const struct iovec *iov, int count);

count 개수 만큼의 iov버퍼에 있는 데이터를 fd에 기록.

read()와 write()와 동일하게 작동 하지만, 여러개의 버퍼를 사용 한다는 점에서 구분됨.


    #include <sys/uio.h>
    
    struct iovec{
    
    void *iov_base; /* 버퍼의 시작 포인터 */
    
    size_t iov_len; /* 버퍼크기*/
    
    };

호출이 성공 했을 때 읽거나 쓴 바이트 개수를 반환. 반환값은 반드시 count * iov_len 값과 같아야됨. 에러 -1 반환



## 메모리에 파일 맵핑하기

리눅스 커널은 표준 파일 입출력의 대안으로 애플리케이션이 파일을 메모리에 맵핑할 수 있는 인터페이스 제공.

개발자는 메모리에 상주하는 데이터처럼 메모리를 통해 파일에 직접 접근 가능.

맵핑된 메모리 주소에 직접 쓴느 것만으로 디스크에 있는 파일에 기록 가능.

### mmap()


    #include <sys/mman.h>;                    
    
    void *mmap(void *addr, size_t len, int prot, int falgs, int fd, off_t offset);
    
    
fd가 가리키는 파일의 offset 위치에서 len바이트 만큼 메모리에 맵핑하도록 커널에 요청.

addr이 포함되면 메모리에서 해당 주소를 선호한다고 커널에 알려줌.

접근 권한은 prot에 지정, 추가적인 동작은 flag에 명시

addr인자는 대부분 0을 넘김.

메모리 맵핑의 실제 시작 주소를 반환함. 실패시 MAP_FAILED 반환

prot

PROT_NONE : 접근이 불가능한 페이지.

PROT_READ : 읽기가 가능한 페이지.

PROT_WRITE : 쓰기가 가능한 페이지.

PROT_EXEC : 실행이 가능한 페이지.

flag

MAP_FIXED : mmap()의 addr인자를 요구사항으로 취급.(0 안됨.) 해당 주소를 확보하지 못하면 실패. 기존 맵핑과 겹칠 경우, 중첩된 페이지는 새로운 맵핑으로 대체.

MAP_PRIVATE : 맵핑이 공유되지 않음을 명시. 

MAP_SHARED : 같은 파일을 맵핑한 모든 프로세스와 맵핑을 공유. 맵핑된 페이지에 쓰기를 하면, 실제 파일에도 동일한 내용을 기록.

MAP_SAHRED 와 MAP_PRIVATE를 함께 지정하면 안 됨.

파일을 맵핑 한 후에 파일 디스크립터를 닫더라도 프로세스는 여전히 맵핑된 주소에 접근 가능.


### 페이지 크기

페이지는 메모리 관리 유닛에서 사용하는 최소 단위.

mmap은 페이지를 다룸.

len인자가 페이지 크그 단위로 정렬되지 않았다면 다음 크기의 페이지 정수배로 확장됨.

### mmunmap()

    #include <sys/mman.h>
    
    int munmap(void *addr, size_t len);

mmap()으로 생성한 맵핑을 헤제.

성공시 0반환, 실패시 -1
    
    
    

### 맵핑 크기 변경하기

    #define _GNU_SOURCE        #include <sys/mman.h>        void *mremap(void *addr, size_t old_size), size_t new_size, unsigned long flags);

[addr, addr+old_size)에 맵핑된 영역을 new_size만큼의 크기로 변경.

커널은 프로세스의 주소 공간에서 사용 가능한 공간과 flags 값에 따라 맵핑된 위츨 변경 가능.

flags 인자는 0 이거나, MREMAP_MAYMOVE] 가능. 후자는 크기 변경 요청을 수행하는 데 필요하다면 맵핑의 위치를 이동해도 괜찮다고 커널에 알려줌.

성공시 크기가 조정된 메모리 맵핑의 시작 주소 반환, 실패시 MAP_FAILED 반환.


### 맵핑의 보호 모드 변경


    #include <sys/mman.h>        int mprotect (const void *addr, size_t len, int prot);


[addr, addr+len)영역 내에 포함된 메모리 페이지의 보호 모드 변경. 리눅스에선느 어떤 메모리 영역에도 사용가능.

성공시 0, 실패시 -1


### 파일과 맵핑의 동기화


    #include <sys/mman.h>        int msync(void *addr, size_t len, int flags);

mmap()으로 맵핑된 파일에 대한 변경 내용ㅇ르 디스크에 기록하여 파일과 맵핑을 동기화 함.

addr 인자는 반드시 페이지 크기로 정령되어야 함. 보통은 mmap()에서 반환값을 이용.

flag는 동기화 방식을 젲어.

MS_SYNC : 디스크에 모든 페이지를 기록하기 전까지 반환하지 않음.

MS_ASYNC : 비동기 방식으로 제어. 갱신작업은 예약되고, 디스크에 페이지가 기록될 때까지 기다리지 않고 즉시 반환.

MS_INVALIDATE : 맵핑의 캐시 복사본을 모두 무효화함. 

MS_SYNC나 MS_ASYNC 중 하나는 반드시 지정해야되지만, 같이 사용은 불가능.


### 맵핑의 사용처 알려주기

    #include <sys/mman.h>        
    
    int madvise(void *addr, size_t len, int advice);

addr로 시작해서 len바이트의 크기를 가지는 메모리 맵핑 내의 페이지와 관련된 동작 방식에 대한 힌트를 커널에 제공

len이 0이면, 커널은 addr에서 시작하는 전체 맵핑에 힌트 적용.



advice 인자

MADV_NORMAL : 평상시와 마찬가지로 동작.

MADV_RANDOM : 미리읽기 사용 안함. 물리적인 읽기 과정에서 최소한의 데이터만 읽어옴.

MADV_SEQUENTIAL : 공격적으로 미이릭기 수행.

MADV_WILLNEED : 커널이 미리읽기를 활성화, 주어진 페이지를 메모리로 읽어 들임.

MADV_DONTNEED : 페이지와 관련된 자원을 해제하고 변경되었지만 아직 동기화 되지 않은 페이지를 버림.    
                이후 맵핑된 데이터에 접근이 발생하면 연관된 파일로부터 페이지의 내용을 채우고, 연관된 파일이 없는 익명 맵핑인 경우에는 요청받은 페이지를 0으로 채움.

MADV_DONTFORK : 프로세스를 포크할 때 자식 프로세스에 해당 페이지가 복사되지는 않도록 함.

MADV_DOFORK+ : MADV_DONTFORK 의 동작방식을 원래래도 되돌림.

성공시 0, 실패시 -1 반환


## 입출력 스케줄러와 성능

디스크와 시스템의 나머지 부분 간의 상대적인 성능차이가 상당히 큼.

디스크의 성능을 가장 심각하게 떨어뜨리는 부분은 탐색이라고 하는 하드 디스크에서 데이터를 읽고 쓰는 헤드를 이동시키는 과정임.

하드 디스크와 나머지 시스템 간의 성능상의 차이 때문에 입출력 요청을 순서대로 디스크로 보내는 방식은 효율적이지 못함.

입출력 스케줄럴르 구현해서 입출력 요청의 순서와 시간을 조작하는 방법으로 디스크 탑색 횟수를 최소화함.


### 디스크 주소 지정방식

CHS(cylinder, head, sector)주소 지정 방식을 사용.

특정 데이터가 저장되어 있는 디스크의 위치를 찾을 때 하드 디스크는 실린더, 헤드, 섹터값을 필요로 함.

실린더 값은 데이터가 위치한 트랙, 헤드 값은 요청한 읽기/쓰기 헤드의 정확한 값을 구분함, 섹터 값을 사용해서 트랙에 위치한 정확한 섹터를 찾ㅈ음.

하드 디스크는 데이터를 찾기 위해 어떤 플래터의 어느 트랙, 어느 섹터에 데이터가 있는 지 알아야 함.


### 입출력 스케줄러의 동작 방식.

병합과 정렬이라는 두 가지 기본 동작을 수행함.


병합은 둘 이상의 인접한 입출력 요청을 단일 요청으로 합치는 과정. 

ex) 하나는 5번, 다른 하나는 6~7 번까지 블록을 읽으려 하면, 5~7번을 읽는 하나의 요청으로 합침.

정렬은 병합보다 더 중요.  대기 중인 입출력 요청을 블록 순서의 오름차순으로 정렬.

ex) 52,109,7에 대한 입출력 연산이 들어오면, 7,52,109 순서대로 정렬함.

이런 방식을 통해 디스크의 헤드 움직임을 최소화 함.


### 읽기 개선

요청한 데이터가 페이지 캐시에 존재하지 않으면 디스크에서 데이터를 읽어올 때까지 블록되어야 하며 이는 시간이 오래 걸릴 수 있는 작업임.

=> 이런 성능 영향ㅇ르 읽기 레이턴시(latency)라고 함.


쓰기 요청은 디스크 성능에 방해가 되지 않느 스트림을 사용. 쓰기 스트림은 커널과 디스크의 주의를 독차지 할 수 있으므로 이런 스트리밍 동작방식은 읽기문제만 복잡하게 됨.

=> 이런 현상을 쓰기가 읽기를 굶겨 죽이는 문제라고 함.


입출력 스케줄러가 항상 요청이 들어온 순서에 따라 새로운 요청을 끼워넣는다면 멀리 떨어진 블록에 대한 요청을 무기한으로 굶겨 죽일 수 있음.

ex) 50번 블록에 대한 새로운 요청이 끊임없이 들어오면 109번 블록에 대한 요청은 절대 처리하지 못할 것임.

입출력 스케줄러는 이런 굶겨 죽이는 사태를 방지 할 수 있는 메커니즘을 도입하고 있음.

리눅스 2.4 커널의 입출력 스케줄러에서 채택한 리누스 엘리베이터 같은 단순한 접근 방식은 큐에 충분히 오래된 요청이 있다면 삽입-정렬기능을 멈춤.

전체 성능을 희생하여 요청에 대한 공정성을 유지하고 읽기 요청일 경우 레이턴시를 개선함.

문제는 이 휴리스틱이 너무 단순함.

리눅스 커널 2.6에서는 리누스 엘리베이터를 사용하지 않고 몇 가지 새로운 입출력 스케줄러를 공개함.

